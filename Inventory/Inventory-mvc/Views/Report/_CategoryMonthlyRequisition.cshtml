<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.1/Chart.min.js"></script>
<script src="~/Scripts/chart-colors.js"></script>
<script src="~/Scripts/Chart.PieceLabel.js"></script>

@{
    string year = (string)ViewBag.Year;
    string month = (string)ViewBag.Month;
    string dept = (string)ViewBag.Dept;
}

<input type="hidden" value="@year" name="year" id="year" />
<input type="hidden" value="@month" name="month" id="month" />
<input type="hidden" value="@dept" name="dept" id="dept" />

<canvas id="myChart"> </canvas>

<script>
    var year = $('#year').val();
    var month = $('#month').val();
    var dept = $('#dept').val();

    var title = 'Requisition Amount of ' + dept;

    if(month == "")
    {
        title = title + ' in Year ' + year;
    }
    else
    {
        title = title + ' in ' + month + ' ' + year;
    }


    var labels = @Html.Raw(Json.Encode(ViewBag.XLabels));
    var doughnutData = @Html.Raw(Json.Encode(ViewBag.YDoughnutData));

    var color = Chart.helpers.color;
    var myChart = document.getElementById("myChart").getContext("2d");

    var backgrdColor = [];
    var colorNames = Object.keys(window.chartColors);

    for (var index = 0; index < labels.length ; index++) 
    {
        var colorName = colorNames[index % colorNames.length];
        var alphaVal = Math.random() * (1 - 0.75) + 0.75;
        var newColor =color(window.chartColors[colorName]).alpha(alphaVal).rgbString();       
        backgrdColor.push(newColor);
    }


    var showQtyChart = new Chart("myChart", {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets:
            [
                {
                    backgroundColor: backgrdColor,
                    data: doughnutData,
                    label: dept,
                },
            ],
        },
        options:
            {
                pieceLabel: 
                {
                    //render: 'value',
                    render: function (args) {
                        return '$ ' + args.value;
                    },
                    fontColor: '#000',
                    position: 'outside',
                    fontSize: 10
                },
                responsive: true,
                legend:
                {
                    display: true,
                    position: 'right',
                    labels:
                    {
                        fontColor: window.chartColors.black,
                    }

                },
                title:
                {
                    display: true,
                    fontSize: 16,
                    fontStyle: 'Bold',
                    text: title,
                },
                animation: 
                {
                    animateScale: true,
                    animateRotate: true,
                }
            }
    });



    //// Define a plugin to provide data labels
    //Chart.plugins.register({
    //    afterDatasetsDraw: function(chart, easing) {
    //        // To only draw at the end of animation, check for easing === 1
    //        var ctx = chart.ctx;

    //        chart.data.datasets.forEach(function (dataset, i) {
    //            var meta = chart.getDatasetMeta(i);
    //            if (!meta.hidden) {
    //                meta.data.forEach(function(element, index) {
    //                    // Draw the text in black, with the specified font
    //                    ctx.fillStyle = 'rgb(0, 0, 0)';

    //                    var fontSize = 12;
    //                    var fontStyle = 'normal';
    //                    var fontFamily = 'Helvetica Neue';
    //                    ctx.font = Chart.helpers.fontString(fontSize, fontStyle, fontFamily);

    //                    // Just naively convert to string for now
    //                    var dataString = dataset.data[index].toString();

    //                    // Make sure alignment settings are correct
    //                    ctx.textAlign = 'center';
    //                    ctx.textBaseline = 'middle';

    //                    var padding = 5;
    //                    var position = element.tooltipPosition();
    //                    ctx.fillText(dataString, position.x, position.y - (fontSize / 2) - padding);
    //                });
    //            }
    //        });
    //    }
    //});
</script>


