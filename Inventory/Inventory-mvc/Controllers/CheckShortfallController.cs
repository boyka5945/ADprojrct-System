using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using Inventory_mvc.Models;
using Inventory_mvc.Entity;
using Inventory_mvc.Service;
using Inventory_mvc.ViewModel;
using PagedList;
using Inventory_mvc.Function;


namespace Inventory_mvc.Controllers
{
    public class CheckShortfallController : Controller
    {
        StationeryModel ctx = new StationeryModel();

        IStationeryService stationeryService = new StationeryService();

        IPurchaseOrderService pos = new PurchaseOrderService();

        Dictionary<Purchase_Detail, string> details = new Dictionary<Purchase_Detail, string>();

        IRequisitionRecordService rrs = new RequisitionRecordService();


        public ActionResult Index()
        {
            return View();
        }

        [RoleAuthorize]
        //Clerk //store supervisor 
        [HttpGet]
        public ActionResult List(int? page)
        {
            //condition for finding items to reorder

            List<StationeryViewModel> model = shortFallList();

            int pageSize = 8;
            int pageNumber = (page ?? 1);
            return View(model.ToPagedList(pageNumber, pageSize));
        }

        [RoleAuthorize]
        //Clerk //store supervisor 
        [HttpGet]
        public ActionResult AddSelected(string checker)
        {

            List<string> itemCodes = new List<string>();
            List<Purchase_Detail> model = new List<Purchase_Detail>();
            Dictionary<string, string> kv = new Dictionary<string, string>(); //kv pair of itemcode and sggestedqty
            List<StationeryViewModel> modelAll = shortFallList(); // used if generate all is chosen

            if (checker == "addAll") //add all
            {

              
                foreach(StationeryViewModel svm in modelAll)
                {
                    itemCodes.Add(svm.ItemCode);
                }


            }

            else
            {
                //list of itemCodes to be reordered
                itemCodes = Request.QueryString.AllKeys.ToList();
                
                foreach (string s in itemCodes) {

                    string v = Request.QueryString.GetValues(s).First();
                    kv.Add(s, v);

                        }
                
            }
            
            ////might need to remove
            //if (Session["detailsBundle"] != null)
            //{
            //    details = (Dictionary<Purchase_Detail, string>)Session["detailsBundle"];
            //    model = details.Keys.ToList<Purchase_Detail>();

            //}

            foreach (string i in itemCodes)
            {
                //takes the price of the first/default supplier
                Stationery s = ctx.Stationeries.Where(x => x.itemCode == i).First();
                decimal price = s.price;
                int qtyToReorder;

                //find qty to reorder
                if (checker == "addAll")
                {
                    StationeryViewModel svm = modelAll.Where(x => x.ItemCode == i).First();
                    qtyToReorder = svm.Suggested;

                }
                else
                {
                    qtyToReorder = Int32.Parse(kv[i]);
                }
                Purchase_Detail pd = new Purchase_Detail();
                pd.orderNo = findNextOrderNo();
                pd.itemCode = i;
                pd.qty = qtyToReorder;
                pd.price = price;
                pd.remarks = String.Format("autogenerated from shortfall list on {0}", DateTime.Now.ToString());
                model.Add(pd);
                //find the default supplier

                string defaultSupplier = ctx.Stationeries.Where(x => x.itemCode == i).First().firstSupplierCode;

                details.Add(pd, defaultSupplier);
                

            }

            
            Session["detailsBundle"] = details;
            //to obtain latest order number
            int orderNo = findNextOrderNo();
            ViewBag.orderNo = orderNo;

            ViewBag.itemCodeList = stationeryService.GetAllItemCodes();
            //return View("~/Views/Purchase/RaisePurchaseOrder.cshtml", model);
 

            return RedirectToAction("RaisePurchaseOrder", "Purchase", model);
        }

        [RoleAuthorize]
        //CLERK
        //helper method
        public int findNextOrderNo()
        {
            using (StationeryModel Entity = new StationeryModel())
            {
                int maxOrderNo = 0;
                //to obtain highest order number
                List<Purchase_Order_Record> pds = Entity.Purchase_Order_Records.ToList();
                foreach (Purchase_Order_Record p in pds)
                {
                    maxOrderNo = 1;
                    if (p.orderNo > maxOrderNo)
                    {
                        maxOrderNo = p.orderNo;
                    }

                }

                return maxOrderNo + 1;
            }

        }

        [RoleAuthorize]
        //CLERK
        //very important helper method
        private List<StationeryViewModel> shortFallList()
        {

            List<StationeryViewModel> items = stationeryService.GetAllStationeryViewModel();

            List<Requisition_Detail> allUnfulfilledRequestDetails = ctx.Requisition_Detail.Where(x => x.fulfilledQty < x.qty).ToList();


            foreach (StationeryViewModel svm in items)
            {

                int unfulfilled = allUnfulfilledRequestDetails.Where(x => x.itemCode == svm.ItemCode && (x.Requisition_Record.status != "Pending Approval" && x.Requisition_Record.status != "Rejected")).Sum(x => x.qty - x.fulfilledQty).Value;
                int index = items.FindIndex(x => x.ItemCode == svm.ItemCode);

                items[index].unFulfilledQty = unfulfilled;
                 
            }

            List<StationeryViewModel> model = items.Where(x => x.StockQty < x.ReorderLevel + x.unFulfilledQty).ToList(); 

            //calculating the suggested qty to order per item
            foreach (StationeryViewModel s in model)
            {
                //suggsted = requested qty(from user) still outstanding + reorder level - qty alrdy ordered
                string itemCode = s.ItemCode;
                int unfulfilledQty = s.unFulfilledQty;
                s.pendingRestockQty = 0;
                int suggested;
                //List<Requisition_Detail> userRequests = ctx.Requisition_Detail.Where(x => x.itemCode == itemCode && x.qty.Value > (x.fulfilledQty ?? 0)).ToList();

                //foreach (Requisition_Detail rd in userRequests)
                //{
                //    unfulfilledQty += (rd.qty.Value - (rd.fulfilledQty ?? 0)); //unfulfilled qty actually
                //}

                int diffBetweenQtyAndMin = s.ReorderLevel - s.StockQty;



                List<Purchase_Detail> existingPurchases = ctx.Purchase_Detail.Where(x => x.itemCode == itemCode && x.qty > (x.fulfilledQty ?? 0)).ToList();


                foreach (Purchase_Detail pd in existingPurchases)
                {
                    if(pd.fulfilledQty == null)
                    {
                        pd.fulfilledQty = 0;
                    }
                    s.pendingRestockQty += (pd.qty - pd.fulfilledQty ?? 0);
                }

                suggested = unfulfilledQty + (s.ReorderLevel - s.StockQty) - s.pendingRestockQty;

                if (suggested > 0 && suggested < s.ReorderQty)
                {
                    suggested = s.ReorderQty;
                }

                if(suggested < 0)
                {
                    suggested = 0;
                }
                s.Suggested = suggested;


            }


            //remove all those with suggested value = 0
            model.RemoveAll(x => x.Suggested == 0);



            return model;
        }
    }
}